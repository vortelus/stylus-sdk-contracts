// Copyright 2023, Offchain Labs, Inc.
// For licensing, see https://github.com/OffchainLabs/stylus-sdk-rs/blob/stylus/licenses/COPYRIGHT.md

//! This module provides functions for code generated by `stylus-sdk-proc`.
//! Most users shouldn't call these.

use crate::{
    abi::{AbiType, ConstString},
    console, msg,
};
use alloy_primitives::U256;
use alloy_sol_types::SolType;

#[inline(always)]
pub fn encode_abi_type<T: AbiType>(x: T) -> Vec<u8> {
    T::SolType::encode_single(&x)
}

#[inline(always)]
pub const fn digest_to_selector(digest: [u8; 32]) -> [u8; 4] {
    let mut selector = [0u8; 4];
    selector[0] = digest[0];
    selector[1] = digest[1];
    selector[2] = digest[2];
    selector[3] = digest[3];
    selector
}

#[allow(unused)]
pub fn deny_value(method_name: &str) -> Result<(), Vec<u8>> {
    if msg::value() == U256::ZERO {
        return Ok(());
    }
    console!("method {method_name} not payable");
    Err(vec![])
}

#[allow(unused)]
pub fn failed_to_decode_arguments(err: alloy_sol_types::Error) {
    console!("failed to decode arguments: {err}");
}

pub trait AbiResult {
    type OkType;
    type ErrType;
}

impl<O, E> AbiResult for Result<O, E> {
    type OkType = O;
    type ErrType = E;
}

pub const fn type_for_solidity<T: AbiType>(is_return: bool) -> ConstString {
    const CALLDATA: ConstString = ConstString::new(" calldata");
    const MEMORY: ConstString = ConstString::new(" memory");

    if <T::SolType as SolType>::DYNAMIC {
        if is_return {
            T::ABI.concat(MEMORY)
        } else {
            T::ABI.concat(CALLDATA)
        }
    } else {
        T::ABI
    }
}

pub fn write_solidity_returns<T: AbiResult>(f: &mut std::fmt::Formatter) -> std::fmt::Result
where
    T::OkType: AbiType,
{
    let abi = type_for_solidity::<T::OkType>(true);
    let abi = abi.as_str();
    if abi == "()" {
        Ok(())
    } else if abi.starts_with('(') {
        write!(f, " returns {}", abi)
    } else {
        write!(f, " returns ({})", abi)
    }
}
